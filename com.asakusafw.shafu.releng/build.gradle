/**
 * Copyright 2013-2021 Asakusa Framework Team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
defaultTasks 'cleanPdeBuild', 'pdeAssemble'

// base source paths directly contains features/plugins
def sourceBases = [
    file('..'),
]
// build target features sort by its build order
def targetFeatures = [
    'com.asakusafw.shafu.feature',
    'com.asakusafw.shafu.asakusafw.feature',
]
def qualifier = System.getProperty('qualifier', "N${new Date().format('yyyyMMddHHmmss')}")
def targetDropinName = 'jinrikisha'

def eclipseUrl = System.getProperty('eclipse.download', 'http://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/kepler/SR2/eclipse-standard-kepler-SR2-win32.zip')

def compilerCompliance = '1.7'
def customBootClasspath = null
def pdeDirectory = new File(buildDir, 'pde')
def toolsDirectory = new File(buildDir, 'pde-tools')

if (System.getProperty('compiler.bootclasspath') != null) {
    customBootClasspath = project.file(System.getProperty('compiler.bootclasspath'))
}

task clean {
    doLast {
        delete(buildDir)
    }
}

task cleanPdeBuild() {
    doLast {
        delete(pdeDirectory)
    }
}

task cleanPdeTools() {
    doLast {
        delete(toolsDirectory)
    }
}

task prepareTools() {
    ext.eclipseSource = null
    ext.eclipseDirectory = null
    if (System.getProperty('eclipse.install')) {
        ext.eclipseSource = System.getProperty('eclipse.install')
        ext.eclipseDirectory = new File(eclipseSource)
        ext.useInstall = true
        if (!ext.eclipseDirectory.isDirectory()) {
            throw new IllegalArgumentException("Invalid -Declipse.install location: ${ext.eclipseDirectory}")
        }
    } else {
        ext.eclipseSource = eclipseUrl
        ext.eclipseDirectory = new File(toolsDirectory, 'eclipse')
        ext.useInstall = false
    }
    inputs.property 'eclipseSource', eclipseSource
    outputs.dir eclipseDirectory
    onlyIf {
        !ext.useInstall
    }
    doLast {
        mkdir(toolsDirectory)
        def marker = new File(eclipseDirectory, ".prepared")
        if (marker.exists()) {
            return
        }
        logging.level = LogLevel.INFO
        def archiveFile = new File(toolsDirectory, 'eclipse.zip')
        ant.get src: eclipseUrl, dest: archiveFile.absolutePath, verbose: true
        copy {
            from zipTree(archiveFile)
            into toolsDirectory
        }
        delete(archiveFile)
        marker.createNewFile()
    }
}

task copySources() {
    ext.pdeBuildDirectory = new File(pdeDirectory, 'build')
    def sourceFeatures = sourceBases*.listFiles().flatten().findAll({ new File(it, 'feature.xml').exists() });
    def sourcePlugins = sourceBases*.listFiles().flatten().findAll({ new File(it, 'plugin.xml').exists() });
    sourceFeatures.each { inputs.dir it }
    sourcePlugins.each { inputs.dir it }
    outputs.dir pdeBuildDirectory
    doLast {
        sourceFeatures.each { f ->
            def dst = new File(pdeBuildDirectory, "features/${f.name}")
            copy {
                from f
                into dst
            }
        }
        sourcePlugins.each { f ->
            def dst = new File(pdeBuildDirectory, "plugins/${f.name}")
            copy {
                from f
                into dst
            }
            delete new File(dst, 'bin')
        }
    }
}

task pdeBuild(dependsOn: [prepareTools, copySources]) {
    ext.productionDirectory = new File(copySources.pdeBuildDirectory, 'prod')
    def eclipseWorking = new File(pdeDirectory, 'eclipse-work')
    doLast {
        if (project.prepareTools.eclipseDirectory.isDirectory() == false) {
            throw new StopExecutionException("Missing Eclipse SDK: ${project.prepareTools.eclipseDirectory}")
        }
        def eclipseLauncher = findPlugin('org.eclipse.equinox.launcher')
        def pdeBuildScript = new File(findPlugin('org.eclipse.pde.build'), 'scripts/build.xml')
        targetFeatures.each { targetFeature ->
            def stdoutLevel = logging.standardOutputCaptureLevel
            try {
                logging.captureStandardOutput LogLevel.INFO
                javaexec {
                    main = 'org.eclipse.equinox.launcher.Main'
                    classpath = files(eclipseLauncher)
                    jvmArgs = [
                        '-Djava.awt.headless=true',
                        '-DtopLevelElementType=feature',
                        '-DtopLevelElementId=' + targetFeature,
                        '-DbuildLabel=' + productionDirectory.name,
                        '-DbuildId=prod',
                        "-DtargetVersion=${baseVersion}.qualifier",
                        "-DforceContextQualifier=${qualifier}",
                        '-DbuildDirectory=' + copySources.pdeBuildDirectory.absolutePath,
                        '-DbaseLocation=' + prepareTools.eclipseDirectory.absolutePath,
                        '-DarchivePrefix=eclipse',
                        '-DcollectingFolder=eclipse',
                        '-DoutputUpdateJars=true',
                        '-DskipBase=true',
                        '-DskipMaps=true',
                        '-DskipFetch=true',
                        '-DlogExtension=.log',
                        '-DjavacDebugInfo=true',
                        '-DjavacFailOnError=true',
                        '-DjavacVerbose=true',
                        '-DjavacSource=' + compilerCompliance,
                        '-DjavacTarget=' + compilerCompliance,
                    ]
                    if (customBootClasspath != null) {
                        jvmArgs("-Dbootclasspath=${customBootClasspath.absolutePath}")
                    }
                    args = [
                        '-data',
                        new File(eclipseWorking, 'data').absolutePath,
                        '-configuration',
                        new File(eclipseWorking, 'configuration').absolutePath,
                        '-application',
                        'org.eclipse.ant.core.antRunner',
                        '-buildfile',
                        pdeBuildScript.absolutePath,
                    ]
                    workingDir = file('scripts')
                }
            } finally {
                logging.captureStandardOutput stdoutLevel
            }
        }
    }
}

task pdeGatherDropin(dependsOn: pdeBuild) {
    ext.pdeDropinDirectory = new File(pdeDirectory, 'dropin')
    def targetDirectory = new File(pdeDropinDirectory, targetDropinName)
    doLast {
        pdeBuild.productionDirectory.listFiles().findAll({ it.name.endsWith('.zip') }).each { archive ->
            copy {
                from zipTree(archive)
                into targetDirectory
            }
        }
        new File(targetDirectory, 'eclipse/features').listFiles().each { f ->
            extractAndDelete(f)
        }
    }
}

task pdeGatherUpdate(dependsOn: pdeBuild) {
    ext.pdeUpdateDirectory = new File(pdeDirectory, 'update')
    doLast {
        pdeBuild.productionDirectory.listFiles().findAll({ it.name.endsWith('.zip') }).each { archive ->
            copy {
                from zipTree(archive)
                into pdeUpdateDirectory
                includeEmptyDirs = false
                eachFile { path = it.path.replaceAll('^.*?/', '') }
            }
        }
    }
}

task pdeAssembleDropin(type: Zip, dependsOn: pdeGatherDropin) {
    destinationDir = buildDir
    archiveName = 'dropin.zip'
    from pdeGatherDropin.pdeDropinDirectory
}

task pdeAssembleUpdate(type: Zip, dependsOn: pdeGatherUpdate) {
    destinationDir = buildDir
    archiveName = 'update-framents.zip'
    from pdeGatherUpdate.pdeUpdateDirectory
}

task pdeAssemble(dependsOn: [pdeAssembleDropin, pdeAssembleUpdate])

def findPlugin(String name) {
    def pluginsDir = new File(project.prepareTools.eclipseDirectory, "plugins")
    if (pluginsDir.isDirectory() == false) {
        return null
    }
    def result = pluginsDir.listFiles().find({ it.name ==~ /${name}_\d+\.\d+\.\d+(\..*)?(\.jar)?/ })
    if (result == null) {
        throw new StopExecutionException("Missing ${name} plugin.")
    }
    return result
}

def extractAndDelete(File file) {
    def dirName = file.name
    if (dirName.endsWith('.jar')) {
        dirName = dirName.substring(0, dirName.length() - 4)
    }
    def dirPath = new File(file.parentFile, dirName)
    project.copy {
        from project.zipTree(file)
        into dirPath
    }
    project.delete(file)
}

